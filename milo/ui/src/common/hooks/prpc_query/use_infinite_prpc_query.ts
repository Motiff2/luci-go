// Copyright 2023 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import {
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  useInfiniteQuery,
} from '@tanstack/react-query';

import {
  useAuthState,
  useGetAccessToken,
} from '@/common/components/auth_state_provider';
import { PrpcClient } from '@/generic_libs/tools/prpc_client';

import { PrpcMethod, PrpcQueryBaseOptions, genPrpcQueryKey } from './common';

export type PaginatedPrpcMethod<
  Req extends { pageToken?: string },
  Ret extends { nextPageToken?: string },
> = PrpcMethod<Req, Ret>;

export type PrpcServicePaginatedMethodKeys<S> = keyof {
  [MK in keyof S as S[MK] extends PaginatedPrpcMethod<
    // The request type has to be `any` because the argument type must be
    // contra-variant when sub-typing a function.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    any,
    { nextPageToken?: string }
  >
    ? MK
    : never]: S[MK];
};

export type PaginatedPrpcMethodRequest<T> = T extends PaginatedPrpcMethod<
  infer Req,
  infer _Res
>
  ? Req
  : never;

export type PaginatedPrpcMethodResponse<T> = T extends PaginatedPrpcMethod<
  infer _Req,
  infer Res
>
  ? Res
  : never;

export interface UseInfinitePrpcQueryOptions<S, MK, Req, Res, TError, TData>
  extends PrpcQueryBaseOptions<S, MK, Omit<Req, 'pageToken'>> {
  /**
   * `options` will be passed to `useInfiniteQuery` from `@tanstack/react-query`.
   */
  readonly options?: Omit<
    UseInfiniteQueryOptions<
      Res,
      TError,
      TData,
      Res,
      readonly [string, string, string, MK, Omit<Req, 'pageToken'>]
    >,
    'queryKey' | 'queryFn' | 'getNextPageParam'
  >;
}

/**
 * Call a pRPC method via `useInfiniteQuery` from `@tanstack/react-query`.
 *
 * Example:
 * ```typescript
 * // The return type is the same as the return type of an equivalent
 * // `useInfiniteQuery` call. i.e. react-query specific type narrowing also
 * // works here. The type of `data` is inferred from the supplied client
 * // implementation and method name.
 * const {data, isLoading, ...} = usePrpcQuery({
 *   // The host of the pRPC server.
 *   host: 'cr-buildbucket-dev.appspot.com',
 *   // The generic client generated by ts-proto.
 *   ClientImpl: BuildsClientImpl,
 *   // The pRPC method to be called. Must be a key of the class supplied to
 *   // `ClientImpl`. The method's request object must have a `pageToken`
 *   // property, and the method's response object must have a `nextPageToken`
 *   // property.
 *   method: 'SearchBuilds',
 *   // A type checked request object. The type of the request object is
 *   // inferred from the supplied client implementation and method name.
 *   request: {
 *     ...
 *   },
 * })
 * ```
 *
 * Comparing to the regular `useInfiniteQuery` hook, this hook
 *  * reduces boilerplate, and
 *  * ensures the `queryKey` is populated correctly.
 */
export function useInfinitePrpcQuery<
  Service extends object,
  MK extends PrpcServicePaginatedMethodKeys<Service>,
  TError = unknown,
  TData = PaginatedPrpcMethodResponse<Service[MK]>,
>(
  opts: UseInfinitePrpcQueryOptions<
    Service,
    MK,
    PaginatedPrpcMethodRequest<Service[MK]>,
    PaginatedPrpcMethodResponse<Service[MK]>,
    TError,
    TData
  >,
): UseInfiniteQueryResult<TData, TError> {
  const { host, insecure, ClientImpl, method, request, options } = opts;

  const { identity } = useAuthState();
  const getAuthToken = useGetAccessToken();
  const queryKey = genPrpcQueryKey(identity, opts);
  return useInfiniteQuery({
    queryKey,
    queryFn: async ({ pageParam = '' }) => {
      const client = new ClientImpl(
        new PrpcClient({ host, insecure, getAuthToken }),
      );

      const req = {
        ...request,
        pageToken: pageParam,
        // We added the pageToken back to the request that omits pageToken.
        // But TSC isn't smart enough to know the final object is a full
        // request.
      } as PaginatedPrpcMethodRequest<Service[MK]>;

      // `method` is constrained to be a key that has an associated property of
      // type `PaginatedPrpcMethod` in a `Service`. Therefore `service[method]`
      // is guaranteed to be a `PaginatedPrpcMethod`. TSC isn't smart enough to
      // know that, so we need to use type casting.
      return await (
        client[method] as PaginatedPrpcMethod<
          PaginatedPrpcMethodRequest<Service[MK]>,
          PaginatedPrpcMethodResponse<Service[MK]>
        >
      )(req);
    },
    getNextPageParam: (lastRes) => lastRes.nextPageToken,
    ...options,
  });
}
