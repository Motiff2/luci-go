// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v5.26.1
// source: go.chromium.org/luci/resultdb/proto/v1/resultdb.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { FieldMask } from "../../../../../google/protobuf/field_mask.pb";
import { Artifact, ArtifactLine } from "./artifact.pb";
import { Instruction, InstructionTarget, instructionTargetFromJSON, instructionTargetToJSON } from "./instruction.pb";
import { Invocation, Sources } from "./invocation.pb";
import {
  ArtifactPredicate,
  TestExonerationPredicate,
  TestMetadataPredicate,
  TestResultPredicate,
} from "./predicate.pb";
import { TestMetadataDetail } from "./test_metadata.pb";
import { TestExoneration, TestResult } from "./test_result.pb";
import { RunTestVerdict, TestVariant, TestVariantPredicate } from "./test_variant.pb";

export const protobufPackage = "luci.resultdb.v1";

/** A request message for GetInvocation RPC. */
export interface GetInvocationRequest {
  /** The name of the invocation to request, see Invocation.name. */
  readonly name: string;
}

/** A request message for GetTestResult RPC. */
export interface GetTestResultRequest {
  /** The name of the test result to request, see TestResult.name. */
  readonly name: string;
}

/** A request message for ListTestResults RPC. */
export interface ListTestResultsRequest {
  /** Name of the invocation, e.g. "invocations/{id}". */
  readonly invocation: string;
  /**
   * The maximum number of test results to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 test results will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `ListTestResults` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListTestResults` MUST
   * match the call that provided the page token.
   */
  readonly pageToken: string;
  /**
   * Fields to include in the response.
   * If not set, the default mask is used where summary_html and tags are
   * excluded.
   * Test result names will always be included even if "name" is not a part of
   * the mask.
   */
  readonly readMask: readonly string[] | undefined;
}

/** A response message for ListTestResults RPC. */
export interface ListTestResultsResponse {
  /** The test results from the specified invocation. */
  readonly testResults: readonly TestResult[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   * If the invocation is not finalized, more results may appear later.
   */
  readonly nextPageToken: string;
}

/** A request message for GetTestExoneration RPC. */
export interface GetTestExonerationRequest {
  /** The name of the test exoneration to request, see TestExoneration.name. */
  readonly name: string;
}

/** A request message for ListTestExonerations RPC. */
export interface ListTestExonerationsRequest {
  /** Name of the invocation, e.g. "invocations/{id}". */
  readonly invocation: string;
  /**
   * The maximum number of test exonerations to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 test exonerations will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `ListTestExonerations` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListTestExonerations`
   * MUST match the call that provided the page token.
   */
  readonly pageToken: string;
}

/** A response message for ListTestExonerations RPC. */
export interface ListTestExonerationsResponse {
  /** The test exonerations from the specified invocation. */
  readonly testExonerations: readonly TestExoneration[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   * If the invocation is not finalized, more results may appear later.
   */
  readonly nextPageToken: string;
}

/** A request message for QueryTestResults RPC. */
export interface QueryTestResultsRequest {
  /**
   * Retrieve test results included in these invocations, directly or indirectly
   * (via Invocation.included_invocations).
   *
   * Specifying multiple invocations is equivalent to querying one invocation
   * that includes these.
   */
  readonly invocations: readonly string[];
  /** A test result in the response must satisfy this predicate. */
  readonly predicate:
    | TestResultPredicate
    | undefined;
  /**
   * The maximum number of test results to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 test results will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `QueryTestResults` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `QueryTestResults` MUST
   * match the call that provided the page token.
   */
  readonly pageToken: string;
  /**
   * Fields to include in the response.
   * If not set, the default mask is used where summary_html and tags are
   * excluded.
   * Test result names will always be included even if "name" is not a part of
   * the mask.
   */
  readonly readMask: readonly string[] | undefined;
}

/** A response message for QueryTestResults RPC. */
export interface QueryTestResultsResponse {
  /**
   * Matched test results.
   * Ordered by parent invocation ID, test ID and result ID.
   */
  readonly testResults: readonly TestResult[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   */
  readonly nextPageToken: string;
}

/** A request message for QueryTestExonerations RPC. */
export interface QueryTestExonerationsRequest {
  /**
   * Retrieve test exonerations included in these invocations, directly or
   * indirectly (via Invocation.included_invocations).
   *
   * Specifying multiple invocations is equivalent to querying one invocation
   * that includes these.
   */
  readonly invocations: readonly string[];
  /** A test exoneration in the response must satisfy this predicate. */
  readonly predicate:
    | TestExonerationPredicate
    | undefined;
  /**
   * The maximum number of test exonerations to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 test exonerations will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `QueryTestExonerations` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `QueryTestExonerations`
   * MUST match the call that provided the page token.
   */
  readonly pageToken: string;
}

/** A response message for QueryTestExonerations RPC. */
export interface QueryTestExonerationsResponse {
  /**
   * The test exonerations matching the predicate.
   * Ordered by parent invocation ID, test ID and exoneration ID.
   */
  readonly testExonerations: readonly TestExoneration[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   */
  readonly nextPageToken: string;
}

/** A request message for QueryTestResultStatistics RPC. */
export interface QueryTestResultStatisticsRequest {
  /**
   * Retrieve statistics of test result belong to these invocations,
   * directly or indirectly (via Invocation.included_invocations).
   *
   * Specifying multiple invocations is equivalent to requesting one invocation
   * that includes these.
   */
  readonly invocations: readonly string[];
}

/** A response message for QueryTestResultStatistics RPC. */
export interface QueryTestResultStatisticsResponse {
  /** Total number of test results. */
  readonly totalTestResults: string;
}

/** A request message for GetArtifact RPC. */
export interface GetArtifactRequest {
  /** The name of the artifact to request, see Artifact.name. */
  readonly name: string;
}

/** A request message for ListArtifacts RPC. */
export interface ListArtifactsRequest {
  /**
   * Name of the parent, e.g. an invocation (see Invocation.name) or
   * a test result (see TestResult.name).
   */
  readonly parent: string;
  /**
   * The maximum number of artifacts to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 artifacts will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `ListArtifacts` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListArtifacts` MUST
   * match the call that provided the page token.
   */
  readonly pageToken: string;
}

/** A response message for ListArtifacts RPC. */
export interface ListArtifactsResponse {
  /** The artifacts from the specified parent. */
  readonly artifacts: readonly Artifact[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   * If the invocation is not finalized, more results may appear later.
   */
  readonly nextPageToken: string;
}

/** A request message for QueryArtifacts RPC. */
export interface QueryArtifactsRequest {
  /**
   * Retrieve artifacts included in these invocations, directly or indirectly
   * (via Invocation.included_invocations and via contained test results).
   *
   * Specifying multiple invocations is equivalent to querying one invocation
   * that includes these.
   */
  readonly invocations: readonly string[];
  /** An artifact in the response must satisfy this predicate. */
  readonly predicate:
    | ArtifactPredicate
    | undefined;
  /**
   * The maximum number of artifacts to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 artifacts will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `QueryArtifacts` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `QueryArtifacts` MUST
   * match the call that provided the page token.
   */
  readonly pageToken: string;
}

/** A response message for QueryArtifacts RPC. */
export interface QueryArtifactsResponse {
  /**
   * Matched artifacts.
   * First invocation-level artifacts, then test-result-level artifacts
   * ordered by parent invocation ID, test ID and artifact ID.
   */
  readonly artifacts: readonly Artifact[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   */
  readonly nextPageToken: string;
}

/** A request message for ListArtifactLines RPC. */
export interface ListArtifactLinesRequest {
  /**
   * Retrieve log lines for this artifact.
   * Format:
   * - For invocation-level artifacts:
   *   "invocations/{INVOCATION_ID}/artifacts/{ARTIFACT_ID}".
   * - For test-result-level artifacts:
   *   "invocations/{INVOCATION_ID}/tests/{URL_ESCAPED_TEST_ID}/results/{RESULT_ID}/artifacts/{ARTIFACT_ID}".
   */
  readonly parent: string;
  /**
   * The maximum number of log lines to return.
   *
   * The service may return fewer than this value.
   * The response size will be truncated to 10MB
   * if the size of matching lines is larger than 10MB.
   * If unspecified or is equal to 0, a max of 10MB of lines will be returned.
   * Negative page sizes are not allowed.
   */
  readonly pageSize: number;
}

/** A response for ListArtifactLines RPC */
export interface ListArtifactLinesResponse {
  /** The log lines in the artifact. */
  readonly lines: readonly ArtifactLine[];
}

/** A request for the QueryArtifactFailureOnlyLines RPC. */
export interface QueryArtifactFailureOnlyLinesRequest {
  /**
   * Retrieve log lines for this artifact.
   * Invocation level artifacts are not yet supported.
   * Format:
   * - For test-result-level artifacts:
   *   "invocations/{INVOCATION_ID}/tests/{URL_ESCAPED_TEST_ID}/results/{RESULT_ID}/artifacts/{ARTIFACT_ID}".
   */
  readonly parent: string;
  /**
   * If set to true, the content of the log lines will be returned in the
   * response.  If left missing or false, only the line range indexes will
   * be returned.
   */
  readonly includeContent: boolean;
  /**
   * The maximum number of line ranges to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 1000 line ranges will be returned.
   * The maximum value is 10,000; values above 10,000 will be coerced to 10,000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `QueryArtifactFailureOnlyLines` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `QueryArtifactFailureOnlyLines` MUST
   * match the call that provided the page token.
   */
  readonly pageToken: string;
}

/** A response for the QueryArtifactFailureOnlyLines RPC. */
export interface QueryArtifactFailureOnlyLinesResponse {
  /**
   * Line ranges [start, end) in the requested artifact that do not typically
   * appear versions of the artifact from passing test results.
   * Line ranges are returned in sorted ascending order.
   */
  readonly failureOnlyLineRanges: readonly QueryArtifactFailureOnlyLinesResponse_LineRange[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   */
  readonly nextPageToken: string;
}

/**
 * A representation of a range of lines in an artifact, where lines are
 * represented by their index.  The first line is line 0.
 */
export interface QueryArtifactFailureOnlyLinesResponse_LineRange {
  /**
   * The line index of the start of the line range.  The start is inclusive,
   * i.e. the start line is included in the range.
   */
  readonly start: number;
  /**
   * The line index of the end of the line range.  The end is exclusive, i.e.
   * the end line is not included in the range.
   */
  readonly end: number;
  /**
   * The content of the lines in the range.
   * Only included if include_content in the request is set to true.
   */
  readonly lines: readonly string[];
}

/**
 * A request message for QueryTestVariants RPC.
 * Next id: 9.
 */
export interface QueryTestVariantsRequest {
  /**
   * Retrieve test verdicts included in these invocations, directly or indirectly
   * (via Invocation.included_invocations).
   *
   * As of April 2024, a maximum of one invocation may be specified.
   */
  readonly invocations: readonly string[];
  /** A test variant must satisfy this predicate. */
  readonly predicate:
    | TestVariantPredicate
    | undefined;
  /**
   * The maximum number of test results to be included in a test variant.
   *
   * If a test variant has more results than the limit, the remaining results
   * will not be returned.
   * If unspecified, at most 10 results will be included in a test variant.
   * The maximum value is 100; values above 100 will be coerced to 100.
   */
  readonly resultLimit: number;
  /**
   * The maximum number of test variants to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 test variants will be returned.
   * The maximum value is 10,000; values above 10,000 will be coerced to 10,000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `QueryTestVariants` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `QueryTestVariants` MUST
   * match the call that provided the page token.
   */
  readonly pageToken: string;
  /**
   * Fields to include in the response.
   * If not set, the default mask is used where all fields are included.
   *
   * The following fields in results.*.result will NEVER be included even when
   * specified:
   * * test_id
   * * variant_hash
   * * variant
   * * test_metadata
   * Those values can be found in the parent test variant objects.
   *
   * The following fields will ALWAYS be included even when NOT specified:
   * * test_id
   * * variant_hash
   * * status
   */
  readonly readMask: readonly string[] | undefined;
}

/** A response message for QueryTestVariants RPC. */
export interface QueryTestVariantsResponse {
  /**
   * Matched test variants.
   * Ordered by TestVariantStatus, test_id, then variant_hash
   */
  readonly testVariants: readonly TestVariant[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   */
  readonly nextPageToken: string;
  /**
   * The code sources tested by the returned test variants. The sources are keyed
   * by an ID which allows them to be cross-referenced from TestVariant.sources_id.
   *
   * The sources are returned via this map instead of directly on the TestVariant
   * to avoid excessive response size. Each source message could be up to a few
   * kilobytes and there are usually no more than a handful of different sources
   * tested in an invocation, so deduplicating them here reduces response size.
   */
  readonly sources: { [key: string]: Sources };
}

export interface QueryTestVariantsResponse_SourcesEntry {
  readonly key: string;
  readonly value: Sources | undefined;
}

/** Request message for QueryRunTestVerdicts RPC. */
export interface QueryRunTestVerdictsRequest {
  /**
   * Retrieve test verdicts for the test run represented by this invocation.
   * Format: invocations/{INVOCATION_ID}.
   */
  readonly invocation: string;
  /**
   * The maximum number of test results to be included in a test variant.
   *
   * If a test variant has more results than the limit, the remaining results
   * will not be returned.
   * If unspecified, at most 10 results will be included in a test variant.
   * The maximum value is 100; values above 100 will be coerced to 100.
   */
  readonly resultLimit: number;
  /**
   * The maximum number of test variants to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 1000 test variants will be returned.
   * The maximum value is 10,000; values above 10,000 will be coerced to 10,000.
   * Page sizes smaller than the maximum may be returned at the server's
   * discretion, for example, due to keep the response size tractable for
   * the server.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `QueryRunTestVerdicts` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `QueryRunTestVerdicts` MUST match the call that provided the page
   * token.
   */
  readonly pageToken: string;
}

/** A response message for QueryRunTestVerdicts RPC. */
export interface QueryRunTestVerdictsResponse {
  /**
   * Test verdicts for the run.
   *
   * Ordered by test_id, then variant_hash.
   */
  readonly runTestVerdicts: readonly RunTestVerdict[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   */
  readonly nextPageToken: string;
}

/** A request message for BatchGetTestVariants RPC. */
export interface BatchGetTestVariantsRequest {
  /** Name of the invocation that the test variants are in. */
  readonly invocation: string;
  /**
   * A list of test IDs and variant hashes, identifying the requested test
   * variants. Size is limited to 500. Any request for more than 500 variants
   * will return an error.
   */
  readonly testVariants: readonly BatchGetTestVariantsRequest_TestVariantIdentifier[];
  /**
   * The maximum number of test results to be included in a test variant.
   *
   * If a test variant has more results than the limit, the remaining results
   * will not be returned.
   * If unspecified, at most 10 results will be included in a test variant.
   * The maximum value is 100; values above 100 will be coerced to 100.
   */
  readonly resultLimit: number;
}

export interface BatchGetTestVariantsRequest_TestVariantIdentifier {
  /**
   * The unique identifier of the test in a LUCI project. See the comment on
   * TestResult.test_id for full documentation.
   */
  readonly testId: string;
  /**
   * Hash of the variant. See the comment on TestResult.variant_hash for full
   * documentation.
   */
  readonly variantHash: string;
}

/** A response message for BatchGetTestVariants RPC. */
export interface BatchGetTestVariantsResponse {
  /**
   * Test variants matching the requests. Any variants that weren't found are
   * omitted from the response. Clients shouldn't rely on the ordering of this
   * field, as no particular order is guaranteed.
   */
  readonly testVariants: readonly TestVariant[];
  /**
   * The code sources tested by the returned test variants. The sources are keyed
   * by an ID which allows them to be cross-referenced from TestVariant.sources_id.
   *
   * The sources are returned via this map instead of directly on the TestVariant
   * to avoid excessive response size. Each source message could be up to a few
   * kilobytes and there are usually no more than a handful of different sources
   * tested in an invocation, so deduplicating them here reduces response size.
   */
  readonly sources: { [key: string]: Sources };
}

export interface BatchGetTestVariantsResponse_SourcesEntry {
  readonly key: string;
  readonly value: Sources | undefined;
}

/** A request message for QueryTestMetadata RPC. */
export interface QueryTestMetadataRequest {
  /** The LUCI Project to query. */
  readonly project: string;
  /** Filters to apply to the returned test metadata. */
  readonly predicate:
    | TestMetadataPredicate
    | undefined;
  /**
   * The maximum number of test metadata entries to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 1000 test metadata entries will be returned.
   * The maximum value is 100K; values above 100K will be coerced to 100K.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `QueryTestMetadata` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `QueryTestMetadata` MUST
   * match the call that provided the page token.
   */
  readonly pageToken: string;
}

/** A response message for QueryTestMetadata RPC. */
export interface QueryTestMetadataResponse {
  /** The matched testMetadata. */
  readonly testMetadata: readonly TestMetadataDetail[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   */
  readonly nextPageToken: string;
}

/**
 * A request message for QueryNewTestVariants RPC.
 * To use this RPC, callers need:
 * - resultdb.baselines.get in the realm the <baseline_project>:@project, where
 *   baseline_project is the LUCI project that contains the baseline.
 * - resultdb.testResults.list in the realm of the invocation which is being
 *   queried.
 */
export interface QueryNewTestVariantsRequest {
  /** Name of the invocation, e.g. "invocations/{id}". */
  readonly invocation: string;
  /**
   * The baseline to compare test variants against, to determine if they are new.
   * e.g. “projects/{project}/baselines/{baseline_id}”.
   * For example, in the project "chromium", the baseline_id may be
   * "try:linux-rel".
   */
  readonly baseline: string;
}

/** A response message for QueryNewTestVariants RPC. */
export interface QueryNewTestVariantsResponse {
  /**
   * Indicates whether the baseline has been populated with at least 72 hours
   * of data and the results can be relied upon.
   */
  readonly isBaselineReady: boolean;
  /**
   * Test variants that are new, meaning that they have not been part of
   * a submitted run prior.
   */
  readonly newTestVariants: readonly QueryNewTestVariantsResponse_NewTestVariant[];
}

/** Represents a new test, which contains minimal information to uniquely identify a TestVariant. */
export interface QueryNewTestVariantsResponse_NewTestVariant {
  /**
   * A unique identifier of the test in a LUCI project.
   * Regex: ^[[::print::]]{1,256}$
   *
   * Refer to TestResult.test_id for details.
   */
  readonly testId: string;
  /**
   * Hash of the variant.
   * hex(sha256(sorted(''.join('%s:%s\n' for k, v in variant.items())))).
   */
  readonly variantHash: string;
}

export interface GetInstructionRequest {
  /**
   * Name of the instruction. The format is:
   * invocations/{invocation_id}/instructions/{instruction_id}
   */
  readonly name: string;
}

/** Request for QueryInstructionDependencies RPC. */
export interface QueryInstructionRequest {
  /**
   * Name of the instruction to query for. The format is:
   * invocations/{invocation_id}/instructions/{instruction_id}
   */
  readonly name: string;
  /**
   * The maximum depth to traverse the dependency chain. Default is 5.
   * The maximum value we support is 10, value bigger than 10 will be adjusted to 10.
   * Non-positive value will be adjusted to the default.
   */
  readonly dependencyMaxDepth: number;
}

/** Response for QueryInstructionDependencies RPC. */
export interface QueryInstructionResponse {
  /** The instruction. */
  readonly instruction:
    | Instruction
    | undefined;
  /** Dependency chain, one for each target. */
  readonly dependencyChains: readonly InstructionDependencyChain[];
}

/** The dependency chain for one target. */
export interface InstructionDependencyChain {
  /** Target of the dependency chain. */
  readonly target: InstructionTarget;
  /**
   * List of dependencies.
   * The list will be sorted by the position in the dependency chain.
   * The direct dependency will be at position 0.
   * If the dependency traversing encounters an error, the last node will contain the error.
   */
  readonly nodes: readonly InstructionDependencyChain_Node[];
}

/** Captures information about a dependency. */
export interface InstructionDependencyChain_Node {
  /**
   * The instruction name that the dependency belongs to.
   * The format is invocations/{invocation_id}/instructions/{instruction_id}.
   * We need this for the UI to resolve the placeholders of the content.
   */
  readonly instructionName: string;
  /**
   * Content of the dependency.
   * Placeholders (if existed) will be returned as-is.
   * The caller of this RPC is responsible for resolving the placeholders.
   */
  readonly content: string;
  /**
   * In case the traversal encounters an error, the error will be returned in this field.
   * If an error is returned, it will only be returned in the last dependency node,
   * after that, the chain will stop.
   */
  readonly error: string;
  /**
   * The descriptive name of the instruction that the dependency belongs to.
   * In the following cases, the descriptive name will not be set:
   * - If the user does not have the permission to access the instruction for the node, or
   * - If the instruction cannot be found.
   */
  readonly descriptiveName: string;
}

function createBaseGetInvocationRequest(): GetInvocationRequest {
  return { name: "" };
}

export const GetInvocationRequest = {
  encode(message: GetInvocationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetInvocationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvocationRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvocationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInvocationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInvocationRequest>): GetInvocationRequest {
    return GetInvocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInvocationRequest>): GetInvocationRequest {
    const message = createBaseGetInvocationRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetTestResultRequest(): GetTestResultRequest {
  return { name: "" };
}

export const GetTestResultRequest = {
  encode(message: GetTestResultRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTestResultRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestResultRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestResultRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTestResultRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTestResultRequest>): GetTestResultRequest {
    return GetTestResultRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTestResultRequest>): GetTestResultRequest {
    const message = createBaseGetTestResultRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTestResultsRequest(): ListTestResultsRequest {
  return { invocation: "", pageSize: 0, pageToken: "", readMask: undefined };
}

export const ListTestResultsRequest = {
  encode(message: ListTestResultsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invocation !== "") {
      writer.uint32(10).string(message.invocation);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.readMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.readMask), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTestResultsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTestResultsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocation = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.readMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTestResultsRequest {
    return {
      invocation: isSet(object.invocation) ? globalThis.String(object.invocation) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      readMask: isSet(object.readMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.readMask)) : undefined,
    };
  },

  toJSON(message: ListTestResultsRequest): unknown {
    const obj: any = {};
    if (message.invocation !== "") {
      obj.invocation = message.invocation;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.readMask !== undefined) {
      obj.readMask = FieldMask.toJSON(FieldMask.wrap(message.readMask));
    }
    return obj;
  },

  create(base?: DeepPartial<ListTestResultsRequest>): ListTestResultsRequest {
    return ListTestResultsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTestResultsRequest>): ListTestResultsRequest {
    const message = createBaseListTestResultsRequest() as any;
    message.invocation = object.invocation ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.readMask = object.readMask ?? undefined;
    return message;
  },
};

function createBaseListTestResultsResponse(): ListTestResultsResponse {
  return { testResults: [], nextPageToken: "" };
}

export const ListTestResultsResponse = {
  encode(message: ListTestResultsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.testResults) {
      TestResult.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTestResultsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTestResultsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testResults.push(TestResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTestResultsResponse {
    return {
      testResults: globalThis.Array.isArray(object?.testResults)
        ? object.testResults.map((e: any) => TestResult.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTestResultsResponse): unknown {
    const obj: any = {};
    if (message.testResults?.length) {
      obj.testResults = message.testResults.map((e) => TestResult.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTestResultsResponse>): ListTestResultsResponse {
    return ListTestResultsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTestResultsResponse>): ListTestResultsResponse {
    const message = createBaseListTestResultsResponse() as any;
    message.testResults = object.testResults?.map((e) => TestResult.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetTestExonerationRequest(): GetTestExonerationRequest {
  return { name: "" };
}

export const GetTestExonerationRequest = {
  encode(message: GetTestExonerationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTestExonerationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestExonerationRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestExonerationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTestExonerationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTestExonerationRequest>): GetTestExonerationRequest {
    return GetTestExonerationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTestExonerationRequest>): GetTestExonerationRequest {
    const message = createBaseGetTestExonerationRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTestExonerationsRequest(): ListTestExonerationsRequest {
  return { invocation: "", pageSize: 0, pageToken: "" };
}

export const ListTestExonerationsRequest = {
  encode(message: ListTestExonerationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invocation !== "") {
      writer.uint32(10).string(message.invocation);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTestExonerationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTestExonerationsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocation = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTestExonerationsRequest {
    return {
      invocation: isSet(object.invocation) ? globalThis.String(object.invocation) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTestExonerationsRequest): unknown {
    const obj: any = {};
    if (message.invocation !== "") {
      obj.invocation = message.invocation;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTestExonerationsRequest>): ListTestExonerationsRequest {
    return ListTestExonerationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTestExonerationsRequest>): ListTestExonerationsRequest {
    const message = createBaseListTestExonerationsRequest() as any;
    message.invocation = object.invocation ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTestExonerationsResponse(): ListTestExonerationsResponse {
  return { testExonerations: [], nextPageToken: "" };
}

export const ListTestExonerationsResponse = {
  encode(message: ListTestExonerationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.testExonerations) {
      TestExoneration.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTestExonerationsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTestExonerationsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testExonerations.push(TestExoneration.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTestExonerationsResponse {
    return {
      testExonerations: globalThis.Array.isArray(object?.testExonerations)
        ? object.testExonerations.map((e: any) => TestExoneration.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTestExonerationsResponse): unknown {
    const obj: any = {};
    if (message.testExonerations?.length) {
      obj.testExonerations = message.testExonerations.map((e) => TestExoneration.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTestExonerationsResponse>): ListTestExonerationsResponse {
    return ListTestExonerationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTestExonerationsResponse>): ListTestExonerationsResponse {
    const message = createBaseListTestExonerationsResponse() as any;
    message.testExonerations = object.testExonerations?.map((e) => TestExoneration.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryTestResultsRequest(): QueryTestResultsRequest {
  return { invocations: [], predicate: undefined, pageSize: 0, pageToken: "", readMask: undefined };
}

export const QueryTestResultsRequest = {
  encode(message: QueryTestResultsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.invocations) {
      writer.uint32(10).string(v!);
    }
    if (message.predicate !== undefined) {
      TestResultPredicate.encode(message.predicate, writer.uint32(18).fork()).ldelim();
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    if (message.readMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.readMask), writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestResultsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestResultsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocations.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.predicate = TestResultPredicate.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.readMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestResultsRequest {
    return {
      invocations: globalThis.Array.isArray(object?.invocations)
        ? object.invocations.map((e: any) => globalThis.String(e))
        : [],
      predicate: isSet(object.predicate) ? TestResultPredicate.fromJSON(object.predicate) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      readMask: isSet(object.readMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.readMask)) : undefined,
    };
  },

  toJSON(message: QueryTestResultsRequest): unknown {
    const obj: any = {};
    if (message.invocations?.length) {
      obj.invocations = message.invocations;
    }
    if (message.predicate !== undefined) {
      obj.predicate = TestResultPredicate.toJSON(message.predicate);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.readMask !== undefined) {
      obj.readMask = FieldMask.toJSON(FieldMask.wrap(message.readMask));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestResultsRequest>): QueryTestResultsRequest {
    return QueryTestResultsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestResultsRequest>): QueryTestResultsRequest {
    const message = createBaseQueryTestResultsRequest() as any;
    message.invocations = object.invocations?.map((e) => e) || [];
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? TestResultPredicate.fromPartial(object.predicate)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.readMask = object.readMask ?? undefined;
    return message;
  },
};

function createBaseQueryTestResultsResponse(): QueryTestResultsResponse {
  return { testResults: [], nextPageToken: "" };
}

export const QueryTestResultsResponse = {
  encode(message: QueryTestResultsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.testResults) {
      TestResult.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestResultsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestResultsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testResults.push(TestResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestResultsResponse {
    return {
      testResults: globalThis.Array.isArray(object?.testResults)
        ? object.testResults.map((e: any) => TestResult.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryTestResultsResponse): unknown {
    const obj: any = {};
    if (message.testResults?.length) {
      obj.testResults = message.testResults.map((e) => TestResult.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestResultsResponse>): QueryTestResultsResponse {
    return QueryTestResultsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestResultsResponse>): QueryTestResultsResponse {
    const message = createBaseQueryTestResultsResponse() as any;
    message.testResults = object.testResults?.map((e) => TestResult.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryTestExonerationsRequest(): QueryTestExonerationsRequest {
  return { invocations: [], predicate: undefined, pageSize: 0, pageToken: "" };
}

export const QueryTestExonerationsRequest = {
  encode(message: QueryTestExonerationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.invocations) {
      writer.uint32(10).string(v!);
    }
    if (message.predicate !== undefined) {
      TestExonerationPredicate.encode(message.predicate, writer.uint32(18).fork()).ldelim();
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestExonerationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestExonerationsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocations.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.predicate = TestExonerationPredicate.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestExonerationsRequest {
    return {
      invocations: globalThis.Array.isArray(object?.invocations)
        ? object.invocations.map((e: any) => globalThis.String(e))
        : [],
      predicate: isSet(object.predicate) ? TestExonerationPredicate.fromJSON(object.predicate) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryTestExonerationsRequest): unknown {
    const obj: any = {};
    if (message.invocations?.length) {
      obj.invocations = message.invocations;
    }
    if (message.predicate !== undefined) {
      obj.predicate = TestExonerationPredicate.toJSON(message.predicate);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestExonerationsRequest>): QueryTestExonerationsRequest {
    return QueryTestExonerationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestExonerationsRequest>): QueryTestExonerationsRequest {
    const message = createBaseQueryTestExonerationsRequest() as any;
    message.invocations = object.invocations?.map((e) => e) || [];
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? TestExonerationPredicate.fromPartial(object.predicate)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryTestExonerationsResponse(): QueryTestExonerationsResponse {
  return { testExonerations: [], nextPageToken: "" };
}

export const QueryTestExonerationsResponse = {
  encode(message: QueryTestExonerationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.testExonerations) {
      TestExoneration.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestExonerationsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestExonerationsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testExonerations.push(TestExoneration.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestExonerationsResponse {
    return {
      testExonerations: globalThis.Array.isArray(object?.testExonerations)
        ? object.testExonerations.map((e: any) => TestExoneration.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryTestExonerationsResponse): unknown {
    const obj: any = {};
    if (message.testExonerations?.length) {
      obj.testExonerations = message.testExonerations.map((e) => TestExoneration.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestExonerationsResponse>): QueryTestExonerationsResponse {
    return QueryTestExonerationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestExonerationsResponse>): QueryTestExonerationsResponse {
    const message = createBaseQueryTestExonerationsResponse() as any;
    message.testExonerations = object.testExonerations?.map((e) => TestExoneration.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryTestResultStatisticsRequest(): QueryTestResultStatisticsRequest {
  return { invocations: [] };
}

export const QueryTestResultStatisticsRequest = {
  encode(message: QueryTestResultStatisticsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.invocations) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestResultStatisticsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestResultStatisticsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestResultStatisticsRequest {
    return {
      invocations: globalThis.Array.isArray(object?.invocations)
        ? object.invocations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: QueryTestResultStatisticsRequest): unknown {
    const obj: any = {};
    if (message.invocations?.length) {
      obj.invocations = message.invocations;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestResultStatisticsRequest>): QueryTestResultStatisticsRequest {
    return QueryTestResultStatisticsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestResultStatisticsRequest>): QueryTestResultStatisticsRequest {
    const message = createBaseQueryTestResultStatisticsRequest() as any;
    message.invocations = object.invocations?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryTestResultStatisticsResponse(): QueryTestResultStatisticsResponse {
  return { totalTestResults: "0" };
}

export const QueryTestResultStatisticsResponse = {
  encode(message: QueryTestResultStatisticsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalTestResults !== "0") {
      writer.uint32(8).int64(message.totalTestResults);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestResultStatisticsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestResultStatisticsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalTestResults = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestResultStatisticsResponse {
    return { totalTestResults: isSet(object.totalTestResults) ? globalThis.String(object.totalTestResults) : "0" };
  },

  toJSON(message: QueryTestResultStatisticsResponse): unknown {
    const obj: any = {};
    if (message.totalTestResults !== "0") {
      obj.totalTestResults = message.totalTestResults;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestResultStatisticsResponse>): QueryTestResultStatisticsResponse {
    return QueryTestResultStatisticsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestResultStatisticsResponse>): QueryTestResultStatisticsResponse {
    const message = createBaseQueryTestResultStatisticsResponse() as any;
    message.totalTestResults = object.totalTestResults ?? "0";
    return message;
  },
};

function createBaseGetArtifactRequest(): GetArtifactRequest {
  return { name: "" };
}

export const GetArtifactRequest = {
  encode(message: GetArtifactRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArtifactRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArtifactRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetArtifactRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetArtifactRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetArtifactRequest>): GetArtifactRequest {
    return GetArtifactRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetArtifactRequest>): GetArtifactRequest {
    const message = createBaseGetArtifactRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListArtifactsRequest(): ListArtifactsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListArtifactsRequest = {
  encode(message: ListArtifactsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListArtifactsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListArtifactsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListArtifactsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListArtifactsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListArtifactsRequest>): ListArtifactsRequest {
    return ListArtifactsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListArtifactsRequest>): ListArtifactsRequest {
    const message = createBaseListArtifactsRequest() as any;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListArtifactsResponse(): ListArtifactsResponse {
  return { artifacts: [], nextPageToken: "" };
}

export const ListArtifactsResponse = {
  encode(message: ListArtifactsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListArtifactsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListArtifactsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListArtifactsResponse {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListArtifactsResponse): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListArtifactsResponse>): ListArtifactsResponse {
    return ListArtifactsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListArtifactsResponse>): ListArtifactsResponse {
    const message = createBaseListArtifactsResponse() as any;
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryArtifactsRequest(): QueryArtifactsRequest {
  return { invocations: [], predicate: undefined, pageSize: 0, pageToken: "" };
}

export const QueryArtifactsRequest = {
  encode(message: QueryArtifactsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.invocations) {
      writer.uint32(10).string(v!);
    }
    if (message.predicate !== undefined) {
      ArtifactPredicate.encode(message.predicate, writer.uint32(18).fork()).ldelim();
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryArtifactsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryArtifactsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocations.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.predicate = ArtifactPredicate.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryArtifactsRequest {
    return {
      invocations: globalThis.Array.isArray(object?.invocations)
        ? object.invocations.map((e: any) => globalThis.String(e))
        : [],
      predicate: isSet(object.predicate) ? ArtifactPredicate.fromJSON(object.predicate) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryArtifactsRequest): unknown {
    const obj: any = {};
    if (message.invocations?.length) {
      obj.invocations = message.invocations;
    }
    if (message.predicate !== undefined) {
      obj.predicate = ArtifactPredicate.toJSON(message.predicate);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryArtifactsRequest>): QueryArtifactsRequest {
    return QueryArtifactsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryArtifactsRequest>): QueryArtifactsRequest {
    const message = createBaseQueryArtifactsRequest() as any;
    message.invocations = object.invocations?.map((e) => e) || [];
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? ArtifactPredicate.fromPartial(object.predicate)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryArtifactsResponse(): QueryArtifactsResponse {
  return { artifacts: [], nextPageToken: "" };
}

export const QueryArtifactsResponse = {
  encode(message: QueryArtifactsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.artifacts) {
      Artifact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryArtifactsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryArtifactsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifacts.push(Artifact.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryArtifactsResponse {
    return {
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryArtifactsResponse): unknown {
    const obj: any = {};
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryArtifactsResponse>): QueryArtifactsResponse {
    return QueryArtifactsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryArtifactsResponse>): QueryArtifactsResponse {
    const message = createBaseQueryArtifactsResponse() as any;
    message.artifacts = object.artifacts?.map((e) => Artifact.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListArtifactLinesRequest(): ListArtifactLinesRequest {
  return { parent: "", pageSize: 0 };
}

export const ListArtifactLinesRequest = {
  encode(message: ListArtifactLinesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListArtifactLinesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListArtifactLinesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListArtifactLinesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListArtifactLinesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListArtifactLinesRequest>): ListArtifactLinesRequest {
    return ListArtifactLinesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListArtifactLinesRequest>): ListArtifactLinesRequest {
    const message = createBaseListArtifactLinesRequest() as any;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListArtifactLinesResponse(): ListArtifactLinesResponse {
  return { lines: [] };
}

export const ListArtifactLinesResponse = {
  encode(message: ListArtifactLinesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.lines) {
      ArtifactLine.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListArtifactLinesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListArtifactLinesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lines.push(ArtifactLine.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListArtifactLinesResponse {
    return {
      lines: globalThis.Array.isArray(object?.lines) ? object.lines.map((e: any) => ArtifactLine.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListArtifactLinesResponse): unknown {
    const obj: any = {};
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => ArtifactLine.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListArtifactLinesResponse>): ListArtifactLinesResponse {
    return ListArtifactLinesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListArtifactLinesResponse>): ListArtifactLinesResponse {
    const message = createBaseListArtifactLinesResponse() as any;
    message.lines = object.lines?.map((e) => ArtifactLine.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryArtifactFailureOnlyLinesRequest(): QueryArtifactFailureOnlyLinesRequest {
  return { parent: "", includeContent: false, pageSize: 0, pageToken: "" };
}

export const QueryArtifactFailureOnlyLinesRequest = {
  encode(message: QueryArtifactFailureOnlyLinesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.includeContent !== false) {
      writer.uint32(16).bool(message.includeContent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryArtifactFailureOnlyLinesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryArtifactFailureOnlyLinesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeContent = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryArtifactFailureOnlyLinesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      includeContent: isSet(object.includeContent) ? globalThis.Boolean(object.includeContent) : false,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryArtifactFailureOnlyLinesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.includeContent !== false) {
      obj.includeContent = message.includeContent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryArtifactFailureOnlyLinesRequest>): QueryArtifactFailureOnlyLinesRequest {
    return QueryArtifactFailureOnlyLinesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryArtifactFailureOnlyLinesRequest>): QueryArtifactFailureOnlyLinesRequest {
    const message = createBaseQueryArtifactFailureOnlyLinesRequest() as any;
    message.parent = object.parent ?? "";
    message.includeContent = object.includeContent ?? false;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryArtifactFailureOnlyLinesResponse(): QueryArtifactFailureOnlyLinesResponse {
  return { failureOnlyLineRanges: [], nextPageToken: "" };
}

export const QueryArtifactFailureOnlyLinesResponse = {
  encode(message: QueryArtifactFailureOnlyLinesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.failureOnlyLineRanges) {
      QueryArtifactFailureOnlyLinesResponse_LineRange.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryArtifactFailureOnlyLinesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryArtifactFailureOnlyLinesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failureOnlyLineRanges.push(
            QueryArtifactFailureOnlyLinesResponse_LineRange.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryArtifactFailureOnlyLinesResponse {
    return {
      failureOnlyLineRanges: globalThis.Array.isArray(object?.failureOnlyLineRanges)
        ? object.failureOnlyLineRanges.map((e: any) => QueryArtifactFailureOnlyLinesResponse_LineRange.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryArtifactFailureOnlyLinesResponse): unknown {
    const obj: any = {};
    if (message.failureOnlyLineRanges?.length) {
      obj.failureOnlyLineRanges = message.failureOnlyLineRanges.map((e) =>
        QueryArtifactFailureOnlyLinesResponse_LineRange.toJSON(e)
      );
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryArtifactFailureOnlyLinesResponse>): QueryArtifactFailureOnlyLinesResponse {
    return QueryArtifactFailureOnlyLinesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryArtifactFailureOnlyLinesResponse>): QueryArtifactFailureOnlyLinesResponse {
    const message = createBaseQueryArtifactFailureOnlyLinesResponse() as any;
    message.failureOnlyLineRanges =
      object.failureOnlyLineRanges?.map((e) => QueryArtifactFailureOnlyLinesResponse_LineRange.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryArtifactFailureOnlyLinesResponse_LineRange(): QueryArtifactFailureOnlyLinesResponse_LineRange {
  return { start: 0, end: 0, lines: [] };
}

export const QueryArtifactFailureOnlyLinesResponse_LineRange = {
  encode(
    message: QueryArtifactFailureOnlyLinesResponse_LineRange,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    for (const v of message.lines) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryArtifactFailureOnlyLinesResponse_LineRange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryArtifactFailureOnlyLinesResponse_LineRange() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lines.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryArtifactFailureOnlyLinesResponse_LineRange {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
      lines: globalThis.Array.isArray(object?.lines) ? object.lines.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: QueryArtifactFailureOnlyLinesResponse_LineRange): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.lines?.length) {
      obj.lines = message.lines;
    }
    return obj;
  },

  create(
    base?: DeepPartial<QueryArtifactFailureOnlyLinesResponse_LineRange>,
  ): QueryArtifactFailureOnlyLinesResponse_LineRange {
    return QueryArtifactFailureOnlyLinesResponse_LineRange.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<QueryArtifactFailureOnlyLinesResponse_LineRange>,
  ): QueryArtifactFailureOnlyLinesResponse_LineRange {
    const message = createBaseQueryArtifactFailureOnlyLinesResponse_LineRange() as any;
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    message.lines = object.lines?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryTestVariantsRequest(): QueryTestVariantsRequest {
  return { invocations: [], predicate: undefined, resultLimit: 0, pageSize: 0, pageToken: "", readMask: undefined };
}

export const QueryTestVariantsRequest = {
  encode(message: QueryTestVariantsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.invocations) {
      writer.uint32(18).string(v!);
    }
    if (message.predicate !== undefined) {
      TestVariantPredicate.encode(message.predicate, writer.uint32(50).fork()).ldelim();
    }
    if (message.resultLimit !== 0) {
      writer.uint32(64).int32(message.resultLimit);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    if (message.readMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.readMask), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestVariantsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestVariantsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invocations.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.predicate = TestVariantPredicate.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.resultLimit = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.readMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestVariantsRequest {
    return {
      invocations: globalThis.Array.isArray(object?.invocations)
        ? object.invocations.map((e: any) => globalThis.String(e))
        : [],
      predicate: isSet(object.predicate) ? TestVariantPredicate.fromJSON(object.predicate) : undefined,
      resultLimit: isSet(object.resultLimit) ? globalThis.Number(object.resultLimit) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      readMask: isSet(object.readMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.readMask)) : undefined,
    };
  },

  toJSON(message: QueryTestVariantsRequest): unknown {
    const obj: any = {};
    if (message.invocations?.length) {
      obj.invocations = message.invocations;
    }
    if (message.predicate !== undefined) {
      obj.predicate = TestVariantPredicate.toJSON(message.predicate);
    }
    if (message.resultLimit !== 0) {
      obj.resultLimit = Math.round(message.resultLimit);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.readMask !== undefined) {
      obj.readMask = FieldMask.toJSON(FieldMask.wrap(message.readMask));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestVariantsRequest>): QueryTestVariantsRequest {
    return QueryTestVariantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestVariantsRequest>): QueryTestVariantsRequest {
    const message = createBaseQueryTestVariantsRequest() as any;
    message.invocations = object.invocations?.map((e) => e) || [];
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? TestVariantPredicate.fromPartial(object.predicate)
      : undefined;
    message.resultLimit = object.resultLimit ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.readMask = object.readMask ?? undefined;
    return message;
  },
};

function createBaseQueryTestVariantsResponse(): QueryTestVariantsResponse {
  return { testVariants: [], nextPageToken: "", sources: {} };
}

export const QueryTestVariantsResponse = {
  encode(message: QueryTestVariantsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.testVariants) {
      TestVariant.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    Object.entries(message.sources).forEach(([key, value]) => {
      QueryTestVariantsResponse_SourcesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestVariantsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestVariantsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testVariants.push(TestVariant.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = QueryTestVariantsResponse_SourcesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.sources[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestVariantsResponse {
    return {
      testVariants: globalThis.Array.isArray(object?.testVariants)
        ? object.testVariants.map((e: any) => TestVariant.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      sources: isObject(object.sources)
        ? Object.entries(object.sources).reduce<{ [key: string]: Sources }>((acc, [key, value]) => {
          acc[key] = Sources.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: QueryTestVariantsResponse): unknown {
    const obj: any = {};
    if (message.testVariants?.length) {
      obj.testVariants = message.testVariants.map((e) => TestVariant.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.sources) {
      const entries = Object.entries(message.sources);
      if (entries.length > 0) {
        obj.sources = {};
        entries.forEach(([k, v]) => {
          obj.sources[k] = Sources.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestVariantsResponse>): QueryTestVariantsResponse {
    return QueryTestVariantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestVariantsResponse>): QueryTestVariantsResponse {
    const message = createBaseQueryTestVariantsResponse() as any;
    message.testVariants = object.testVariants?.map((e) => TestVariant.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.sources = Object.entries(object.sources ?? {}).reduce<{ [key: string]: Sources }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Sources.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseQueryTestVariantsResponse_SourcesEntry(): QueryTestVariantsResponse_SourcesEntry {
  return { key: "", value: undefined };
}

export const QueryTestVariantsResponse_SourcesEntry = {
  encode(message: QueryTestVariantsResponse_SourcesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Sources.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestVariantsResponse_SourcesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestVariantsResponse_SourcesEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Sources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestVariantsResponse_SourcesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Sources.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: QueryTestVariantsResponse_SourcesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Sources.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestVariantsResponse_SourcesEntry>): QueryTestVariantsResponse_SourcesEntry {
    return QueryTestVariantsResponse_SourcesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestVariantsResponse_SourcesEntry>): QueryTestVariantsResponse_SourcesEntry {
    const message = createBaseQueryTestVariantsResponse_SourcesEntry() as any;
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Sources.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseQueryRunTestVerdictsRequest(): QueryRunTestVerdictsRequest {
  return { invocation: "", resultLimit: 0, pageSize: 0, pageToken: "" };
}

export const QueryRunTestVerdictsRequest = {
  encode(message: QueryRunTestVerdictsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invocation !== "") {
      writer.uint32(10).string(message.invocation);
    }
    if (message.resultLimit !== 0) {
      writer.uint32(16).int32(message.resultLimit);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRunTestVerdictsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRunTestVerdictsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocation = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.resultLimit = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRunTestVerdictsRequest {
    return {
      invocation: isSet(object.invocation) ? globalThis.String(object.invocation) : "",
      resultLimit: isSet(object.resultLimit) ? globalThis.Number(object.resultLimit) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryRunTestVerdictsRequest): unknown {
    const obj: any = {};
    if (message.invocation !== "") {
      obj.invocation = message.invocation;
    }
    if (message.resultLimit !== 0) {
      obj.resultLimit = Math.round(message.resultLimit);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryRunTestVerdictsRequest>): QueryRunTestVerdictsRequest {
    return QueryRunTestVerdictsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryRunTestVerdictsRequest>): QueryRunTestVerdictsRequest {
    const message = createBaseQueryRunTestVerdictsRequest() as any;
    message.invocation = object.invocation ?? "";
    message.resultLimit = object.resultLimit ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryRunTestVerdictsResponse(): QueryRunTestVerdictsResponse {
  return { runTestVerdicts: [], nextPageToken: "" };
}

export const QueryRunTestVerdictsResponse = {
  encode(message: QueryRunTestVerdictsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.runTestVerdicts) {
      RunTestVerdict.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRunTestVerdictsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRunTestVerdictsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.runTestVerdicts.push(RunTestVerdict.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRunTestVerdictsResponse {
    return {
      runTestVerdicts: globalThis.Array.isArray(object?.runTestVerdicts)
        ? object.runTestVerdicts.map((e: any) => RunTestVerdict.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryRunTestVerdictsResponse): unknown {
    const obj: any = {};
    if (message.runTestVerdicts?.length) {
      obj.runTestVerdicts = message.runTestVerdicts.map((e) => RunTestVerdict.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryRunTestVerdictsResponse>): QueryRunTestVerdictsResponse {
    return QueryRunTestVerdictsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryRunTestVerdictsResponse>): QueryRunTestVerdictsResponse {
    const message = createBaseQueryRunTestVerdictsResponse() as any;
    message.runTestVerdicts = object.runTestVerdicts?.map((e) => RunTestVerdict.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseBatchGetTestVariantsRequest(): BatchGetTestVariantsRequest {
  return { invocation: "", testVariants: [], resultLimit: 0 };
}

export const BatchGetTestVariantsRequest = {
  encode(message: BatchGetTestVariantsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invocation !== "") {
      writer.uint32(10).string(message.invocation);
    }
    for (const v of message.testVariants) {
      BatchGetTestVariantsRequest_TestVariantIdentifier.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.resultLimit !== 0) {
      writer.uint32(24).int32(message.resultLimit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchGetTestVariantsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetTestVariantsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocation = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.testVariants.push(BatchGetTestVariantsRequest_TestVariantIdentifier.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.resultLimit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetTestVariantsRequest {
    return {
      invocation: isSet(object.invocation) ? globalThis.String(object.invocation) : "",
      testVariants: globalThis.Array.isArray(object?.testVariants)
        ? object.testVariants.map((e: any) => BatchGetTestVariantsRequest_TestVariantIdentifier.fromJSON(e))
        : [],
      resultLimit: isSet(object.resultLimit) ? globalThis.Number(object.resultLimit) : 0,
    };
  },

  toJSON(message: BatchGetTestVariantsRequest): unknown {
    const obj: any = {};
    if (message.invocation !== "") {
      obj.invocation = message.invocation;
    }
    if (message.testVariants?.length) {
      obj.testVariants = message.testVariants.map((e) => BatchGetTestVariantsRequest_TestVariantIdentifier.toJSON(e));
    }
    if (message.resultLimit !== 0) {
      obj.resultLimit = Math.round(message.resultLimit);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchGetTestVariantsRequest>): BatchGetTestVariantsRequest {
    return BatchGetTestVariantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchGetTestVariantsRequest>): BatchGetTestVariantsRequest {
    const message = createBaseBatchGetTestVariantsRequest() as any;
    message.invocation = object.invocation ?? "";
    message.testVariants =
      object.testVariants?.map((e) => BatchGetTestVariantsRequest_TestVariantIdentifier.fromPartial(e)) || [];
    message.resultLimit = object.resultLimit ?? 0;
    return message;
  },
};

function createBaseBatchGetTestVariantsRequest_TestVariantIdentifier(): BatchGetTestVariantsRequest_TestVariantIdentifier {
  return { testId: "", variantHash: "" };
}

export const BatchGetTestVariantsRequest_TestVariantIdentifier = {
  encode(
    message: BatchGetTestVariantsRequest_TestVariantIdentifier,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.testId !== "") {
      writer.uint32(10).string(message.testId);
    }
    if (message.variantHash !== "") {
      writer.uint32(18).string(message.variantHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchGetTestVariantsRequest_TestVariantIdentifier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetTestVariantsRequest_TestVariantIdentifier() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.variantHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetTestVariantsRequest_TestVariantIdentifier {
    return {
      testId: isSet(object.testId) ? globalThis.String(object.testId) : "",
      variantHash: isSet(object.variantHash) ? globalThis.String(object.variantHash) : "",
    };
  },

  toJSON(message: BatchGetTestVariantsRequest_TestVariantIdentifier): unknown {
    const obj: any = {};
    if (message.testId !== "") {
      obj.testId = message.testId;
    }
    if (message.variantHash !== "") {
      obj.variantHash = message.variantHash;
    }
    return obj;
  },

  create(
    base?: DeepPartial<BatchGetTestVariantsRequest_TestVariantIdentifier>,
  ): BatchGetTestVariantsRequest_TestVariantIdentifier {
    return BatchGetTestVariantsRequest_TestVariantIdentifier.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchGetTestVariantsRequest_TestVariantIdentifier>,
  ): BatchGetTestVariantsRequest_TestVariantIdentifier {
    const message = createBaseBatchGetTestVariantsRequest_TestVariantIdentifier() as any;
    message.testId = object.testId ?? "";
    message.variantHash = object.variantHash ?? "";
    return message;
  },
};

function createBaseBatchGetTestVariantsResponse(): BatchGetTestVariantsResponse {
  return { testVariants: [], sources: {} };
}

export const BatchGetTestVariantsResponse = {
  encode(message: BatchGetTestVariantsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.testVariants) {
      TestVariant.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.sources).forEach(([key, value]) => {
      BatchGetTestVariantsResponse_SourcesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchGetTestVariantsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetTestVariantsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testVariants.push(TestVariant.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = BatchGetTestVariantsResponse_SourcesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.sources[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetTestVariantsResponse {
    return {
      testVariants: globalThis.Array.isArray(object?.testVariants)
        ? object.testVariants.map((e: any) => TestVariant.fromJSON(e))
        : [],
      sources: isObject(object.sources)
        ? Object.entries(object.sources).reduce<{ [key: string]: Sources }>((acc, [key, value]) => {
          acc[key] = Sources.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BatchGetTestVariantsResponse): unknown {
    const obj: any = {};
    if (message.testVariants?.length) {
      obj.testVariants = message.testVariants.map((e) => TestVariant.toJSON(e));
    }
    if (message.sources) {
      const entries = Object.entries(message.sources);
      if (entries.length > 0) {
        obj.sources = {};
        entries.forEach(([k, v]) => {
          obj.sources[k] = Sources.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BatchGetTestVariantsResponse>): BatchGetTestVariantsResponse {
    return BatchGetTestVariantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchGetTestVariantsResponse>): BatchGetTestVariantsResponse {
    const message = createBaseBatchGetTestVariantsResponse() as any;
    message.testVariants = object.testVariants?.map((e) => TestVariant.fromPartial(e)) || [];
    message.sources = Object.entries(object.sources ?? {}).reduce<{ [key: string]: Sources }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Sources.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBatchGetTestVariantsResponse_SourcesEntry(): BatchGetTestVariantsResponse_SourcesEntry {
  return { key: "", value: undefined };
}

export const BatchGetTestVariantsResponse_SourcesEntry = {
  encode(message: BatchGetTestVariantsResponse_SourcesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Sources.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchGetTestVariantsResponse_SourcesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetTestVariantsResponse_SourcesEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Sources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetTestVariantsResponse_SourcesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Sources.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BatchGetTestVariantsResponse_SourcesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Sources.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchGetTestVariantsResponse_SourcesEntry>): BatchGetTestVariantsResponse_SourcesEntry {
    return BatchGetTestVariantsResponse_SourcesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchGetTestVariantsResponse_SourcesEntry>,
  ): BatchGetTestVariantsResponse_SourcesEntry {
    const message = createBaseBatchGetTestVariantsResponse_SourcesEntry() as any;
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Sources.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseQueryTestMetadataRequest(): QueryTestMetadataRequest {
  return { project: "", predicate: undefined, pageSize: 0, pageToken: "" };
}

export const QueryTestMetadataRequest = {
  encode(message: QueryTestMetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.predicate !== undefined) {
      TestMetadataPredicate.encode(message.predicate, writer.uint32(18).fork()).ldelim();
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestMetadataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestMetadataRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.predicate = TestMetadataPredicate.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestMetadataRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      predicate: isSet(object.predicate) ? TestMetadataPredicate.fromJSON(object.predicate) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryTestMetadataRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.predicate !== undefined) {
      obj.predicate = TestMetadataPredicate.toJSON(message.predicate);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestMetadataRequest>): QueryTestMetadataRequest {
    return QueryTestMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestMetadataRequest>): QueryTestMetadataRequest {
    const message = createBaseQueryTestMetadataRequest() as any;
    message.project = object.project ?? "";
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? TestMetadataPredicate.fromPartial(object.predicate)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryTestMetadataResponse(): QueryTestMetadataResponse {
  return { testMetadata: [], nextPageToken: "" };
}

export const QueryTestMetadataResponse = {
  encode(message: QueryTestMetadataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.testMetadata) {
      TestMetadataDetail.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTestMetadataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestMetadataResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testMetadata.push(TestMetadataDetail.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestMetadataResponse {
    return {
      testMetadata: globalThis.Array.isArray(object?.testMetadata)
        ? object.testMetadata.map((e: any) => TestMetadataDetail.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryTestMetadataResponse): unknown {
    const obj: any = {};
    if (message.testMetadata?.length) {
      obj.testMetadata = message.testMetadata.map((e) => TestMetadataDetail.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestMetadataResponse>): QueryTestMetadataResponse {
    return QueryTestMetadataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestMetadataResponse>): QueryTestMetadataResponse {
    const message = createBaseQueryTestMetadataResponse() as any;
    message.testMetadata = object.testMetadata?.map((e) => TestMetadataDetail.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryNewTestVariantsRequest(): QueryNewTestVariantsRequest {
  return { invocation: "", baseline: "" };
}

export const QueryNewTestVariantsRequest = {
  encode(message: QueryNewTestVariantsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invocation !== "") {
      writer.uint32(10).string(message.invocation);
    }
    if (message.baseline !== "") {
      writer.uint32(18).string(message.baseline);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryNewTestVariantsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNewTestVariantsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocation = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.baseline = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNewTestVariantsRequest {
    return {
      invocation: isSet(object.invocation) ? globalThis.String(object.invocation) : "",
      baseline: isSet(object.baseline) ? globalThis.String(object.baseline) : "",
    };
  },

  toJSON(message: QueryNewTestVariantsRequest): unknown {
    const obj: any = {};
    if (message.invocation !== "") {
      obj.invocation = message.invocation;
    }
    if (message.baseline !== "") {
      obj.baseline = message.baseline;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNewTestVariantsRequest>): QueryNewTestVariantsRequest {
    return QueryNewTestVariantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNewTestVariantsRequest>): QueryNewTestVariantsRequest {
    const message = createBaseQueryNewTestVariantsRequest() as any;
    message.invocation = object.invocation ?? "";
    message.baseline = object.baseline ?? "";
    return message;
  },
};

function createBaseQueryNewTestVariantsResponse(): QueryNewTestVariantsResponse {
  return { isBaselineReady: false, newTestVariants: [] };
}

export const QueryNewTestVariantsResponse = {
  encode(message: QueryNewTestVariantsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isBaselineReady !== false) {
      writer.uint32(8).bool(message.isBaselineReady);
    }
    for (const v of message.newTestVariants) {
      QueryNewTestVariantsResponse_NewTestVariant.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryNewTestVariantsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNewTestVariantsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isBaselineReady = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newTestVariants.push(QueryNewTestVariantsResponse_NewTestVariant.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNewTestVariantsResponse {
    return {
      isBaselineReady: isSet(object.isBaselineReady) ? globalThis.Boolean(object.isBaselineReady) : false,
      newTestVariants: globalThis.Array.isArray(object?.newTestVariants)
        ? object.newTestVariants.map((e: any) => QueryNewTestVariantsResponse_NewTestVariant.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryNewTestVariantsResponse): unknown {
    const obj: any = {};
    if (message.isBaselineReady !== false) {
      obj.isBaselineReady = message.isBaselineReady;
    }
    if (message.newTestVariants?.length) {
      obj.newTestVariants = message.newTestVariants.map((e) => QueryNewTestVariantsResponse_NewTestVariant.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNewTestVariantsResponse>): QueryNewTestVariantsResponse {
    return QueryNewTestVariantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNewTestVariantsResponse>): QueryNewTestVariantsResponse {
    const message = createBaseQueryNewTestVariantsResponse() as any;
    message.isBaselineReady = object.isBaselineReady ?? false;
    message.newTestVariants =
      object.newTestVariants?.map((e) => QueryNewTestVariantsResponse_NewTestVariant.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryNewTestVariantsResponse_NewTestVariant(): QueryNewTestVariantsResponse_NewTestVariant {
  return { testId: "", variantHash: "" };
}

export const QueryNewTestVariantsResponse_NewTestVariant = {
  encode(message: QueryNewTestVariantsResponse_NewTestVariant, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.testId !== "") {
      writer.uint32(10).string(message.testId);
    }
    if (message.variantHash !== "") {
      writer.uint32(18).string(message.variantHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryNewTestVariantsResponse_NewTestVariant {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNewTestVariantsResponse_NewTestVariant() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.variantHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNewTestVariantsResponse_NewTestVariant {
    return {
      testId: isSet(object.testId) ? globalThis.String(object.testId) : "",
      variantHash: isSet(object.variantHash) ? globalThis.String(object.variantHash) : "",
    };
  },

  toJSON(message: QueryNewTestVariantsResponse_NewTestVariant): unknown {
    const obj: any = {};
    if (message.testId !== "") {
      obj.testId = message.testId;
    }
    if (message.variantHash !== "") {
      obj.variantHash = message.variantHash;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNewTestVariantsResponse_NewTestVariant>): QueryNewTestVariantsResponse_NewTestVariant {
    return QueryNewTestVariantsResponse_NewTestVariant.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<QueryNewTestVariantsResponse_NewTestVariant>,
  ): QueryNewTestVariantsResponse_NewTestVariant {
    const message = createBaseQueryNewTestVariantsResponse_NewTestVariant() as any;
    message.testId = object.testId ?? "";
    message.variantHash = object.variantHash ?? "";
    return message;
  },
};

function createBaseGetInstructionRequest(): GetInstructionRequest {
  return { name: "" };
}

export const GetInstructionRequest = {
  encode(message: GetInstructionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetInstructionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstructionRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstructionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInstructionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInstructionRequest>): GetInstructionRequest {
    return GetInstructionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInstructionRequest>): GetInstructionRequest {
    const message = createBaseGetInstructionRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseQueryInstructionRequest(): QueryInstructionRequest {
  return { name: "", dependencyMaxDepth: 0 };
}

export const QueryInstructionRequest = {
  encode(message: QueryInstructionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dependencyMaxDepth !== 0) {
      writer.uint32(16).int32(message.dependencyMaxDepth);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryInstructionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInstructionRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dependencyMaxDepth = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryInstructionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dependencyMaxDepth: isSet(object.dependencyMaxDepth) ? globalThis.Number(object.dependencyMaxDepth) : 0,
    };
  },

  toJSON(message: QueryInstructionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dependencyMaxDepth !== 0) {
      obj.dependencyMaxDepth = Math.round(message.dependencyMaxDepth);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryInstructionRequest>): QueryInstructionRequest {
    return QueryInstructionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryInstructionRequest>): QueryInstructionRequest {
    const message = createBaseQueryInstructionRequest() as any;
    message.name = object.name ?? "";
    message.dependencyMaxDepth = object.dependencyMaxDepth ?? 0;
    return message;
  },
};

function createBaseQueryInstructionResponse(): QueryInstructionResponse {
  return { instruction: undefined, dependencyChains: [] };
}

export const QueryInstructionResponse = {
  encode(message: QueryInstructionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instruction !== undefined) {
      Instruction.encode(message.instruction, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.dependencyChains) {
      InstructionDependencyChain.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryInstructionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInstructionResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instruction = Instruction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dependencyChains.push(InstructionDependencyChain.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryInstructionResponse {
    return {
      instruction: isSet(object.instruction) ? Instruction.fromJSON(object.instruction) : undefined,
      dependencyChains: globalThis.Array.isArray(object?.dependencyChains)
        ? object.dependencyChains.map((e: any) => InstructionDependencyChain.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryInstructionResponse): unknown {
    const obj: any = {};
    if (message.instruction !== undefined) {
      obj.instruction = Instruction.toJSON(message.instruction);
    }
    if (message.dependencyChains?.length) {
      obj.dependencyChains = message.dependencyChains.map((e) => InstructionDependencyChain.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryInstructionResponse>): QueryInstructionResponse {
    return QueryInstructionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryInstructionResponse>): QueryInstructionResponse {
    const message = createBaseQueryInstructionResponse() as any;
    message.instruction = (object.instruction !== undefined && object.instruction !== null)
      ? Instruction.fromPartial(object.instruction)
      : undefined;
    message.dependencyChains = object.dependencyChains?.map((e) => InstructionDependencyChain.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInstructionDependencyChain(): InstructionDependencyChain {
  return { target: 0, nodes: [] };
}

export const InstructionDependencyChain = {
  encode(message: InstructionDependencyChain, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.target !== 0) {
      writer.uint32(8).int32(message.target);
    }
    for (const v of message.nodes) {
      InstructionDependencyChain_Node.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InstructionDependencyChain {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstructionDependencyChain() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodes.push(InstructionDependencyChain_Node.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstructionDependencyChain {
    return {
      target: isSet(object.target) ? instructionTargetFromJSON(object.target) : 0,
      nodes: globalThis.Array.isArray(object?.nodes)
        ? object.nodes.map((e: any) => InstructionDependencyChain_Node.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InstructionDependencyChain): unknown {
    const obj: any = {};
    if (message.target !== 0) {
      obj.target = instructionTargetToJSON(message.target);
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => InstructionDependencyChain_Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InstructionDependencyChain>): InstructionDependencyChain {
    return InstructionDependencyChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstructionDependencyChain>): InstructionDependencyChain {
    const message = createBaseInstructionDependencyChain() as any;
    message.target = object.target ?? 0;
    message.nodes = object.nodes?.map((e) => InstructionDependencyChain_Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInstructionDependencyChain_Node(): InstructionDependencyChain_Node {
  return { instructionName: "", content: "", error: "", descriptiveName: "" };
}

export const InstructionDependencyChain_Node = {
  encode(message: InstructionDependencyChain_Node, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instructionName !== "") {
      writer.uint32(10).string(message.instructionName);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    if (message.descriptiveName !== "") {
      writer.uint32(34).string(message.descriptiveName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InstructionDependencyChain_Node {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstructionDependencyChain_Node() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instructionName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.descriptiveName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstructionDependencyChain_Node {
    return {
      instructionName: isSet(object.instructionName) ? globalThis.String(object.instructionName) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      descriptiveName: isSet(object.descriptiveName) ? globalThis.String(object.descriptiveName) : "",
    };
  },

  toJSON(message: InstructionDependencyChain_Node): unknown {
    const obj: any = {};
    if (message.instructionName !== "") {
      obj.instructionName = message.instructionName;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.descriptiveName !== "") {
      obj.descriptiveName = message.descriptiveName;
    }
    return obj;
  },

  create(base?: DeepPartial<InstructionDependencyChain_Node>): InstructionDependencyChain_Node {
    return InstructionDependencyChain_Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstructionDependencyChain_Node>): InstructionDependencyChain_Node {
    const message = createBaseInstructionDependencyChain_Node() as any;
    message.instructionName = object.instructionName ?? "";
    message.content = object.content ?? "";
    message.error = object.error ?? "";
    message.descriptiveName = object.descriptiveName ?? "";
    return message;
  },
};

/** Service to read test results. */
export interface ResultDB {
  /** Retrieves an invocation. */
  GetInvocation(request: GetInvocationRequest): Promise<Invocation>;
  /** Retrieves a test result. */
  GetTestResult(request: GetTestResultRequest): Promise<TestResult>;
  /**
   * Retrieves test results for a parent invocation.
   *
   * Note: response does not contain test results of included invocations.
   * Use QueryTestResults instead.
   */
  ListTestResults(request: ListTestResultsRequest): Promise<ListTestResultsResponse>;
  /** Retrieves a test exoneration. */
  GetTestExoneration(request: GetTestExonerationRequest): Promise<TestExoneration>;
  /**
   * Retrieves test exonerations for a parent invocation.
   *
   * Note: response does not contain test results of included invocations.
   * Use QueryTestExonerations instead.
   */
  ListTestExonerations(request: ListTestExonerationsRequest): Promise<ListTestExonerationsResponse>;
  /**
   * Retrieves test results from an invocation, recursively.
   * Supports invocation inclusions.
   * Supports advanced filtering.
   * Examples: go/resultdb-rpc#querytestresults
   */
  QueryTestResults(request: QueryTestResultsRequest): Promise<QueryTestResultsResponse>;
  /**
   * Retrieves test exonerations from an invocation.
   * Supports invocation inclusions.
   * Supports advanced filtering.
   */
  QueryTestExonerations(request: QueryTestExonerationsRequest): Promise<QueryTestExonerationsResponse>;
  /**
   * Retrieves the test result statistics of an invocation.
   * Currently supports total number of test results belong to the invocation,
   * directly and indirectly.
   */
  QueryTestResultStatistics(request: QueryTestResultStatisticsRequest): Promise<QueryTestResultStatisticsResponse>;
  /**
   * Calculate new test variants by running the difference between the tests
   * run in the given invocation against the submitted test history for the
   * source.
   */
  QueryNewTestVariants(request: QueryNewTestVariantsRequest): Promise<QueryNewTestVariantsResponse>;
  /** Retrieves an artifact. */
  GetArtifact(request: GetArtifactRequest): Promise<Artifact>;
  /**
   * Retrieves artifacts for a parent invocation/testResult.
   *
   * Note: if the parent is an invocation, the response does not contain
   * artifacts of included invocations. Use QueryArtifacts instead.
   */
  ListArtifacts(request: ListArtifactsRequest): Promise<ListArtifactsResponse>;
  /**
   * Retrieves artifacts from an invocation, recursively.
   * Can retrieve artifacts of test results included in the invocation
   * directly or indirectly.
   * Supports invocation inclusions.
   */
  QueryArtifacts(request: QueryArtifactsRequest): Promise<QueryArtifactsResponse>;
  /**
   * Retrieves test verdicts for a test run. A test run comprises only
   * the test results from a single invocation and not its included
   * invocations.
   *
   * Useful to incrementally ingest test results for an export root as its
   * individual constituent invocations finalize, in conjunction with
   * the invocations-ready-for-export pub/sub.
   *
   * Compared to the ListTestResults RPC, this RPC ensures all results
   * for a test variant are returned together, which is useful when
   * ingesting results into analyses that treat retried test results
   * in a given test run differently to the first retry.
   *
   * To use, the caller must have `resultdb.testResults.list` permission
   * on the queried invocation.
   */
  QueryRunTestVerdicts(request: QueryRunTestVerdictsRequest): Promise<QueryRunTestVerdictsResponse>;
  /**
   * Lists the artifact contents as a list of log lines and
   * performs best effort extraction of log information
   * such as severity and timestamp for each line.
   *
   * Currently supports artifacts with content types: [text/plain,]
   */
  ListArtifactLines(request: ListArtifactLinesRequest): Promise<ListArtifactLinesResponse>;
  /**
   * Retrieves the line ranges in the given failure that do not usually appear
   * in logs from passes.
   *
   * Lines are normalized before comparison to remove numbers, dates, tmp file
   * paths, etc.
   *
   * Due to missed normalizations, sampling error or other reasons, this may
   * not eliminate all lines that appear in passes.
   */
  QueryArtifactFailureOnlyLines(
    request: QueryArtifactFailureOnlyLinesRequest,
  ): Promise<QueryArtifactFailureOnlyLinesResponse>;
  /**
   * Retrieves test verdicts from an invocation, recursively.
   * Supports invocation inclusions.
   */
  QueryTestVariants(request: QueryTestVariantsRequest): Promise<QueryTestVariantsResponse>;
  /**
   * Retrieves test variants from a single invocation, matching the specified
   * test IDs and hashes.
   */
  BatchGetTestVariants(request: BatchGetTestVariantsRequest): Promise<BatchGetTestVariantsResponse>;
  /** Retrieves test metadata from a LUCI project, matching the predicate. */
  QueryTestMetadata(request: QueryTestMetadataRequest): Promise<QueryTestMetadataResponse>;
  /**
   * Retrieves an instruction for step or test result.
   * If the instruction contains placeholders, they will not be replaced.
   * The callers of this RPC are responsible to populate the placeholders with real data.
   */
  GetInstruction(request: GetInstructionRequest): Promise<Instruction>;
  /**
   * Retrieves the instruction and the dependency chain for all targets.
   * A maximum depth can be specified for the maximum number of dependency nodes to be returned.
   * If an error occurs while traversing a chain (e.g. circular dependency, permission, not found...),
   * the chain will stop and the rpc will return whatever it has found so far.
   */
  QueryInstruction(request: QueryInstructionRequest): Promise<QueryInstructionResponse>;
}

export const ResultDBServiceName = "luci.resultdb.v1.ResultDB";
export class ResultDBClientImpl implements ResultDB {
  static readonly DEFAULT_SERVICE = ResultDBServiceName;
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ResultDBServiceName;
    this.rpc = rpc;
    this.GetInvocation = this.GetInvocation.bind(this);
    this.GetTestResult = this.GetTestResult.bind(this);
    this.ListTestResults = this.ListTestResults.bind(this);
    this.GetTestExoneration = this.GetTestExoneration.bind(this);
    this.ListTestExonerations = this.ListTestExonerations.bind(this);
    this.QueryTestResults = this.QueryTestResults.bind(this);
    this.QueryTestExonerations = this.QueryTestExonerations.bind(this);
    this.QueryTestResultStatistics = this.QueryTestResultStatistics.bind(this);
    this.QueryNewTestVariants = this.QueryNewTestVariants.bind(this);
    this.GetArtifact = this.GetArtifact.bind(this);
    this.ListArtifacts = this.ListArtifacts.bind(this);
    this.QueryArtifacts = this.QueryArtifacts.bind(this);
    this.QueryRunTestVerdicts = this.QueryRunTestVerdicts.bind(this);
    this.ListArtifactLines = this.ListArtifactLines.bind(this);
    this.QueryArtifactFailureOnlyLines = this.QueryArtifactFailureOnlyLines.bind(this);
    this.QueryTestVariants = this.QueryTestVariants.bind(this);
    this.BatchGetTestVariants = this.BatchGetTestVariants.bind(this);
    this.QueryTestMetadata = this.QueryTestMetadata.bind(this);
    this.GetInstruction = this.GetInstruction.bind(this);
    this.QueryInstruction = this.QueryInstruction.bind(this);
  }
  GetInvocation(request: GetInvocationRequest): Promise<Invocation> {
    const data = GetInvocationRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "GetInvocation", data);
    return promise.then((data) => Invocation.fromJSON(data));
  }

  GetTestResult(request: GetTestResultRequest): Promise<TestResult> {
    const data = GetTestResultRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "GetTestResult", data);
    return promise.then((data) => TestResult.fromJSON(data));
  }

  ListTestResults(request: ListTestResultsRequest): Promise<ListTestResultsResponse> {
    const data = ListTestResultsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ListTestResults", data);
    return promise.then((data) => ListTestResultsResponse.fromJSON(data));
  }

  GetTestExoneration(request: GetTestExonerationRequest): Promise<TestExoneration> {
    const data = GetTestExonerationRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "GetTestExoneration", data);
    return promise.then((data) => TestExoneration.fromJSON(data));
  }

  ListTestExonerations(request: ListTestExonerationsRequest): Promise<ListTestExonerationsResponse> {
    const data = ListTestExonerationsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ListTestExonerations", data);
    return promise.then((data) => ListTestExonerationsResponse.fromJSON(data));
  }

  QueryTestResults(request: QueryTestResultsRequest): Promise<QueryTestResultsResponse> {
    const data = QueryTestResultsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryTestResults", data);
    return promise.then((data) => QueryTestResultsResponse.fromJSON(data));
  }

  QueryTestExonerations(request: QueryTestExonerationsRequest): Promise<QueryTestExonerationsResponse> {
    const data = QueryTestExonerationsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryTestExonerations", data);
    return promise.then((data) => QueryTestExonerationsResponse.fromJSON(data));
  }

  QueryTestResultStatistics(request: QueryTestResultStatisticsRequest): Promise<QueryTestResultStatisticsResponse> {
    const data = QueryTestResultStatisticsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryTestResultStatistics", data);
    return promise.then((data) => QueryTestResultStatisticsResponse.fromJSON(data));
  }

  QueryNewTestVariants(request: QueryNewTestVariantsRequest): Promise<QueryNewTestVariantsResponse> {
    const data = QueryNewTestVariantsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryNewTestVariants", data);
    return promise.then((data) => QueryNewTestVariantsResponse.fromJSON(data));
  }

  GetArtifact(request: GetArtifactRequest): Promise<Artifact> {
    const data = GetArtifactRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "GetArtifact", data);
    return promise.then((data) => Artifact.fromJSON(data));
  }

  ListArtifacts(request: ListArtifactsRequest): Promise<ListArtifactsResponse> {
    const data = ListArtifactsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ListArtifacts", data);
    return promise.then((data) => ListArtifactsResponse.fromJSON(data));
  }

  QueryArtifacts(request: QueryArtifactsRequest): Promise<QueryArtifactsResponse> {
    const data = QueryArtifactsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryArtifacts", data);
    return promise.then((data) => QueryArtifactsResponse.fromJSON(data));
  }

  QueryRunTestVerdicts(request: QueryRunTestVerdictsRequest): Promise<QueryRunTestVerdictsResponse> {
    const data = QueryRunTestVerdictsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryRunTestVerdicts", data);
    return promise.then((data) => QueryRunTestVerdictsResponse.fromJSON(data));
  }

  ListArtifactLines(request: ListArtifactLinesRequest): Promise<ListArtifactLinesResponse> {
    const data = ListArtifactLinesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ListArtifactLines", data);
    return promise.then((data) => ListArtifactLinesResponse.fromJSON(data));
  }

  QueryArtifactFailureOnlyLines(
    request: QueryArtifactFailureOnlyLinesRequest,
  ): Promise<QueryArtifactFailureOnlyLinesResponse> {
    const data = QueryArtifactFailureOnlyLinesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryArtifactFailureOnlyLines", data);
    return promise.then((data) => QueryArtifactFailureOnlyLinesResponse.fromJSON(data));
  }

  QueryTestVariants(request: QueryTestVariantsRequest): Promise<QueryTestVariantsResponse> {
    const data = QueryTestVariantsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryTestVariants", data);
    return promise.then((data) => QueryTestVariantsResponse.fromJSON(data));
  }

  BatchGetTestVariants(request: BatchGetTestVariantsRequest): Promise<BatchGetTestVariantsResponse> {
    const data = BatchGetTestVariantsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "BatchGetTestVariants", data);
    return promise.then((data) => BatchGetTestVariantsResponse.fromJSON(data));
  }

  QueryTestMetadata(request: QueryTestMetadataRequest): Promise<QueryTestMetadataResponse> {
    const data = QueryTestMetadataRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryTestMetadata", data);
    return promise.then((data) => QueryTestMetadataResponse.fromJSON(data));
  }

  GetInstruction(request: GetInstructionRequest): Promise<Instruction> {
    const data = GetInstructionRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "GetInstruction", data);
    return promise.then((data) => Instruction.fromJSON(data));
  }

  QueryInstruction(request: QueryInstructionRequest): Promise<QueryInstructionResponse> {
    const data = QueryInstructionRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryInstruction", data);
    return promise.then((data) => QueryInstructionResponse.fromJSON(data));
  }
}

interface Rpc {
  request(service: string, method: string, data: unknown): Promise<unknown>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
