// Copyright 2022 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package luci.analysis.internal.tasks;

import "google/protobuf/timestamp.proto";
import "go.chromium.org/luci/analysis/internal/ingestion/control/proto/control.proto";
import "go.chromium.org/luci/resultdb/proto/v1/notification.proto";

option go_package = "go.chromium.org/luci/analysis/internal/tasks/taskspb";

// Payload of IngestTestVerdicts task.
message IngestTestVerdicts {
  // Timestamp representing the start of the data retention period
  // for the ingested test verdicts. In case of multiple builds
  // ingested for one CV run, the partition_time used for all
  // builds must be the same.
  google.protobuf.Timestamp partition_time = 1;

  // The build that is being ingested.
  luci.analysis.internal.ingestion.control.BuildResult build = 2;

  // Context about the presubmit run the build was a part of. Only
  // populated if the build is a presubmit run.
  luci.analysis.internal.ingestion.control.PresubmitResult presubmit_run = 3;

  // The page token value to use when calling QueryTestVariants.
  // For the first task, this should be "". For subsequent tasks,
  // this is the next_page_token value returned by the last call.
  string page_token = 4;

  // The task number of test results task. 0 for the first
  // task, 1 for the second task, and so on. Used to avoid creating
  // duplicate tasks.
  int64 task_index = 5;
}

// Payload of IngestTestResults task.
message IngestTestResults {
  // The ResultDB invocation ready for export notification that triggered
  // the ingestion of test results.
  luci.resultdb.v1.InvocationReadyForExportNotification notification = 1;

  // The page token value to use when calling ListTestResults.
  // For the first task, this should be "". For subsequent tasks,
  // this is the next_page_token value returned by the last call.
  string page_token = 2;

  // The task number of test results task. 0 for the first
  // task, 1 for the second task, and so on. Used to avoid creating
  // duplicate tasks.
  int64 task_index = 3;
}

// Payload of the ReclusterChunks task.
message ReclusterChunks {
  // The number of the reclustering shard being processed by this task.
  // A shard corresponds to a project + Chunk ID keyspace fraction that
  // is being re-clustered.
  // Shards are numbered sequentially, starting at one.
  int64 shard_number = 6;

  // The LUCI Project containing test results to be re-clustered.
  string project = 1;

  // The attempt time for which this task is. This should be cross-referenced
  // with the ReclusteringRuns table to identify the reclustering parameters.
  // This is also the soft deadline for the task.
  google.protobuf.Timestamp attempt_time = 2;

  // The exclusive lower bound defining the range of Chunk IDs to
  // be re-clustered. To define the table start, use the empty string ("").
  string start_chunk_id = 3;

  // The inclusive upper bound defining the range of Chunk IDs to
  // be re-clustered. To define the table end use "ff" x 16, i.e.
  // "ffffffffffffffffffffffffffffffff".
  string end_chunk_id = 4;

  // The version of algorithms to re-cluster to. If the worker executing the
  // task is not running at least this version of algorithms, it is an error.
  int64 algorithms_version = 7;

  // The version of rules to recluster to.
  google.protobuf.Timestamp rules_version = 8;

  // The version of project configuration to recluster to.
  google.protobuf.Timestamp config_version = 9;

  // State to be passed from one execution of the task to the next.
  // To fit with autoscaling, each task aims to execute only for a short time
  // before enqueuing another task to act as its continuation.
  // Must be populated on all tasks, even on the initial task.
  ReclusterChunkState state = 5;
}

// ReclusterChunkState captures state passed from one execution of a
// ReclusterChunks task to the next.
message ReclusterChunkState {
  // The exclusive lower bound of Chunk IDs processed to date.
  string current_chunk_id = 1;

  // The next time a progress report should be made.
  google.protobuf.Timestamp next_report_due = 2;
}

// Payload of the JoinBuild task.
message JoinBuild {
  // Buildbucket build ID, unique per Buildbucket instance.
  int64 id = 1;

  // Buildbucket host, e.g. "cr-buildbucket.appspot.com".
  string host = 2;

  // The LUCI Project to which the build belongs.
  string project = 3;
}

// Payload of the UpdateBugs task. Prior to running this task,
// the cluster_summaries table should have been updated from the
// contents of the clustered_failures table.
message UpdateBugs {
  // The LUCI Project to update bugs for.
  string project = 1;

  // The reclustering attempt minute that reflects the reclustering
  // state of the failures summarized by the cluster_summaries table.
  //
  // Explanation:
  // Bug management relies upon knowing when reclustering
  // is ongoing for rules and algorithms to inhibit erroneous bug updates
  // for those rules / algorithms as cluster metrics may be invalid.
  //
  // The re-clustering progress tracked in ReclusteringRuns table tracks
  // the progress applying re-clustering to the clustered_failures
  // table (not the cluster_summaries table).
  // As there is a delay between when clustered_failures table
  // is updated and when cluster_summaries is updated, we cannot
  // use the latest reclustering run but need to read the run
  // that was current when the clustered_failures table was
  // summarized into the cluster_summaries table.
  //
  // This will be the run that was current when the BigQuery
  // job to recompute cluster_summaries table from the
  // clustered_failures table started.
  google.protobuf.Timestamp reclustering_attempt_minute = 2;

  // The time the task should be completed by to avoid overruning
  // the next bug update task.
  google.protobuf.Timestamp deadline = 3;
}
